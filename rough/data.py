# AUTOGENERATED! DO NOT EDIT! File to edit: ..\00_data.ipynb.

# %% auto 0
__all__ = ['gen_rot_prof', 'image2xyz', 'fit_plane', 'smooth_image', 'gen_sections']

# %% ..\00_data.ipynb 5
import numpy as np
import imutils
import cv2 as cv
from matplotlib import pyplot as plt
import scipy.ndimage as ndimage
import scipy

# %% ..\00_data.ipynb 14
def gen_rot_prof(array, #2D array of height values
                     deg = 180, #Number of degrees to rotate through, i.e 180 gives full 360 rotation
                     increment = 1 # indent/180 = number of evenly spaced profiles to calculate.  
                    ):
    ''' Generates an array of rotational profiles through to deg, in even increments of increment. 
    Uses OpenCV and Imutils to rotate the array around the center of the array/raster/image, extracts the middle row. 
    '''
    if deg % increment != 0:
        raise ValueError('Cannot sample evenly, deg % indent must = 0')
    profiles = np.zeros(shape = (deg//increment,array.shape[0]))
    index = 0
    center = array.shape[0]//2  #Center is returned as index to the right of center for even arrays
    for degree in range(0, deg, increment):
        rot_array = imutils.rotate(array, angle = degree)
        profiles[index, :] = rot_array[center,:]
        index += 1
    return profiles
            

# %% ..\00_data.ipynb 16
def image2xyz(im):
    '''
    Converts 2D (m,n) image/array to xyz coordinates. Used for plane levelling
    '''
    
    m, n = im.shape
    Y, X = np.mgrid[:m,:n]
    xyz = np.column_stack((X.ravel(),Y.ravel(), im.ravel()))
    
    return xyz

# %% ..\00_data.ipynb 19
def fit_plane(im, # 2D Numpy array or array like 
              to_xyz = True #Convert (m,n) matrix to (n,3) points 
             ):
    '''
    Fits plane to xyz data, returns the computed values over the shape of the original (m,n) image
    '''
    if to_xyz:
        im = image2xyz(im)
    #data = image2xyz(image)
    xs = im[:,0]
    ys = im[:,1]
    zs = im[:,2]
    A = np.c_[xs, ys, np.ones(im.shape[0])]
    C,_,_,_ = scipy.linalg.lstsq(A, zs) #Compute coefficients 
    
    X,Y = np.meshgrid(np.arange(0, np.max(xs)+1, 1), np.arange(0, np.max(ys)+1, 1)) #Grid over ther range of pixel coords
    
    Z = C[0]*X + C[1]*Y + C[2] #Compute values over the grid
    
    return Z 

# %% ..\00_data.ipynb 25
def smooth_image(array, #Numpy array or array like
                 sigma = 1, #Standard deviation for gaussian kernel Useful for determining the wavelength of the low pass filter
                 **kwargs #Keyword arguments for modification of the gaussian_filter function
                ):
    '''
    Removes low frequency/wavelength features ('noise') by applying a gaussian filter on the image. 
    Thin wrapper of scipy.ndimage.gaussian_filter.
    '''
    return ndimage.gaussian_filter(input = array, sigma = sigma, **kwargs)

# %% ..\00_data.ipynb 28
def gen_sections(array #2D array (or arraylike) of height values
                ):
    pass
                 
